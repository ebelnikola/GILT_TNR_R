# Naming convention

The database handling in this repository is not perfect. We acknowledge it could be improved, but we are following the saying "if it ain't broke, don't fix it". Important data generated by the code will use the following naming convention:
```
rotate=[rotate]_[chi]_[gilt_eps]_[cg_eps]__[info about particular experiment].[extension]
```
The first part of the name `rotate=[rotate]_[chi]_[gilt_eps]_[cg_eps]` uniquely characterizes the GiltTNR algorithm, with one caveat. This naming convention assumes that `bond_repetitions`, `recursion_depth`, and `Rmatrices` were not provided (see the list of adjustments in the GiltTNR directory section). Two functions generate database entries using this convention: trajectory and plot_the_trajectory (specifically, their methods with the `initialA_pars` argument). <span style="color: red;">To avoid ambiguities in the database, users should not pass `bond_repetitions`, `recursion_depth`, or `Rmatrices` to these functions.</span>

# Files and directories description

<span style="color: red;">REMINDER TO ADD LINK TO THE PAPER</span>

## GiltTNR directory
This directory contains Python code implementing the GiltTNR algorithm (see [this paper](https://journals.aps.org/prb/abstract/10.1103/PhysRevB.97.045111)). It combines code from [GiltTNR](https://github.com/GiltTNR/GiltTNR), [ncon](https://github.com/mhauru/ncon), and [abeliantensors](https://github.com/mhauru/abeliantensors). We made the following adjustments:

1. Added an option to fix the number of Gilt algorithm iterations applied to each bond around a plaquette, controlled by the `bond_repetitions` keyword argument.

2. Added an option to fix the recursion depth in the optimization procedure for `R` matrices (`Q` matrices in the [paper]()). This is controlled by the `recursion_depth` keyword argument (used with `bond_repetitions`), which is a dictionary with keys from `{"S", "N", "E", "W"}` and values specifying recursion depths for corresponding legs. Note: At the last Gilt iteration, recursion depth is automatically set to 1 for all legs.

3. Added an option to use precomputed `R` matrices instead of running the optimization procedure. Pass `bond_repetitions` and the `Rmatrices` keyword argument, a dictionary with keys `(bond_key, lap)` (`lap` is an integer, `bond_key in {"S", "N", "E", "W"}`) and values as `R` matrices to be applied at the specified bond and Gilt iteration.

4. Added an option to control tensor rotation after the GiltTNR step, controlled by the `rotate` keyword.

5. Modified `matrix_eig` and `matrix_svd` functions in `abeliantensor.py` to remove sign ambiguities in the decomposition. Two methods are available, controlled by the global variable `method` at the beginning of `abeliantensor.py` and `tensor.py`.

## Lab directory

Contains scripts for computations:

- ```plot_trajectory.jl``` applies the ```GiltTNR``` algorithm ```traj_len``` times to the initial tensor corresponding to 2d nearest neighbors Ising model at the relative temperature ```relT```. It saves the resulting trajectories to the "trajectories" folder in two files: ```*.data``` with tensors, log factors, and errors along the trajectory; ```*.log``` with all the text output of the algorithm. It also saves the plots of the trajectories of the tensor's singular values (obtained by "diagonal" SVD: $A_{ijkl}=U_{ij l} S_l V_{l kl}$).

- ```critical_temperature.jl``` finds the critical temperature using bisection search; saves the result into the "critical_temperatures" directory; plots the corresponding trajectories of the singular values. Saves the plot into the "trajectory_plots" directory. 
 
- ```differentiability_test.jl``` performs differentiability tests of the GiltTNR algorithm. Fixes ```bond_repetitions``` and ```recursion_depth```. Then, chooses a random direction $v$ and computes the numerical derivative $\Delta_n=(GiltTNR(A+s_n v/2)-GiltTNR(A-s_n v/2))/s_n$, where $s_n=10^{-3-0.05n}$. Plots $|\Delta_{n+1}-\Delta_n|/|\Delta_n|$ vs $n$ and saves this plot into the "results" directory. The approximate minimum of this plot should be chosen as the step size in ```newton.jl```. If parameter ```N``` is passed, the script will perform the test for ```N``` random directions. 

- ```eigensystem.jl``` gets the largest eigenvalues and the corresponding eigenvectors of GiltTNR linearised around some initial approximation of the critical tensor (given by ```relT``` and ```number_of_initial_steps```). Saves the resulting tensor and the eigensystem to ```eigensystems```. Note that the script will fix ```bond_repetitions``` and ```recursion_depth```. These parameters will be saved together with the other output.  

- ```newton.jl``` (assumes that ```rotation=true```) repeats the computation from ```eigensystem.jl```. Then, it finds the critical tensor using Newton's method and computes the eigensystem for the linearisation of GiltTNR around this tensor. Saves the resulting tensor and the eigensystem to the "newton" directory. It also saves Newton's method convergence plot to the same directory and the singular values trajectory plot starting from the found tensor. Note that the found critical tensor is the fixed point for gilt with fixed ```bond_repetitions``` and ```recursion_depth```. These parameters will be saved together with the other output.

Note that each script has the corresponding help describing all the command line arguments. To see this help run 
```
julia Lab/script_name.jl --help
```

## Files in the root directory

- ```EchelonForm.jl``` - technical code used in ```GaugeFixing.jl``` for checking ranks of boolean matrices. 
- ```GaugeFixing.jl``` - continuous and discrete gauge fixing routines.
- ```install_packages.jl``` - script that installs all the necessary dependencies and creates the necessary directories.
- ```KrylovTechnical.jl``` - technical code that provides a minimal implementation of Z2 invariant tensors in Julia. This solves the problem of ```KrylovKit``` throwing a segmentation fault while working with PyObjects.
- ```NumDifferentiation.jl``` - provides the function that performs numerical differentiation.
- ```Tools.jl``` - Contains user-dedicated functions. These are listed at the top of the file.     
- ```IsingExactLevels``` and ```IsingEvenExactLevels``` - data about exact 2d Ising spectrum.

# Reproducing all the data from the paper
 
Ensure that your working directory is the root directory of this project. Then, run the ```install_packages.jl``` script to install all the necessary dependencies and create directories for other scripts: 
```
   julia install_packages.jl
```

## Eigenvalues of GiltTNR without rotation at an approximate fixed point

Let us do the computation for $\chi=10$, $gilt eps=1e-4$. To get an approximate fixed point we run the bisection search:
```
nohup julia Lab/critical_temperature.jl --chi 10 --gilt_eps 1e-4 --search_tol 1e-10 &
```

The script will produce the singular values trajectory plot corresponding to the found approximation of the critical temperature. The plot exhibits a plateau corresponding to the part of the trajectory close to the critical tensor. We choose one tensor at this plateau as an approximation of the critical tensor, say the 15th one. Before computing the eigensystem we run the differentiability test and find the optimal differentiation step. Here is the command for this:  

```
nohup julia Lab/differentiability_test.jl --chi 10 --gilt_eps 1e-4 --relT 1.001277863197029 --number_of_initial_steps 15 --N 5 &
```

Note that ```differentiability_test``` will fix the ```bond_repetitions``` and ```recursion_depth```. This should make the resulting RG map differentiable. The script will fix ```bond_repetitions=2```. As for the ```recursion_depth```, it will read off the recursion depths used in GiltTNR before these manipulations and use these values.

Checking the Cauchy test plots in the "diff_tests" directory we see that derivatives converge. The slope of the lines is around $-2$ which is consistent with the numerical differentiation algorithm of order $2$ that is used in the script by default. We also see that stepsize $5e-6$ is an appropriate choice.  

Finally, we may run ```eigensystem.jl``` (no "nohup" this time as it is nice to see the correct eigenvalues printed out in the terminal):
```
julia Lab/eigensystem.jl --chi 10 --gilt_eps 1e-4 --relT 1.001277863197029 --number_of_initial_steps 15 --stp 5e-6 --N 20
```
## Critical fixed point of GiltTNR with rotation

Let us again consider $\chi=10$ and $gilt eps=1e-4$. We need some initial approximation for the critical tensor. Let us run the trajectory at $relT=1$ and check if we see a plateau there.  
```
nohup julia Lab/plot_trajectory.jl --chi 10 --gilt_eps 1e-4 --relT 1.0 --rotate true
``` 

Let us try to use the 5th tensor as the initial approximation:
```
julia Lab/newton.jl --chi 10 --gilt_eps 1e-4 --relT 1.0 --number_of_initial_steps 5 --N 23
```


## Anisotropic intial tensor A

TK (April 5) : This is a temporary stash of info that should eventually be incorporated in Readme.md in a more organized way.

Right now the code that allows anisotropic initial A is in a fork GILT_TNR_R_tk of the original repository GILT_TNR_R.

The initial tensor now depends on two parameters : relT and Jratio. The function initial_tensor() now calls get_initial_tensor_aniso() instead of get_initial_tensor() as before. The function get_initial_tensor_aniso() is defined in GiltTNR2D_Ising_benchmarks.py. It defines a tensor corresponding to the Ising model with Jv/Jh=Jratio and T = relT * T_c. So relT is always the critical case. Note that T_c depends on Jratio. The routine computes T_c. 

relT and Jratio are passed as a dictionary with a name like initialA_pars and entries "relT" and "Jratio". Where ever relT was passed before, it has now been replaced by passing a dictionary (with name that begins with initialA_pars). 

I have tried to make everything backwards compatible with Jratio defaulting to 1. For example, 

```
nohup julia Lab/plot_trajectory.jl --chi 10 --gilt_eps 1e-4 --relT 1.0 --rotate true
``` 
should work as before. Adding Jratio:

```
nohup julia Lab/plot_trajectory.jl --chi 10 --gilt_eps 1e-4 --relT 1.0 --Jratio 0.58 --rotate true
``` 

should generate a trajectory with initial A for the critical model with Jratio=0.58. Of course it is not exactly critical since chi is finite.

database: If Jratio==1, files are named as before. If Jratio is not 1, the file name contains both relT and Jratio.

At the moment you get some compiler warnings from some of my function definitions that need to be cleaned up.

I have checked that plot_trajectory.jl, critical_temperature.jl, plot_trajectory.jl run ok. But I have yet to check all the other programs. 

There are some bash scripts named run... that I use to avoid having to type all the parameters each time I run something. 
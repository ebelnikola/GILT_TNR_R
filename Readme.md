# Naming convention

The method of work with the database in this repository is not ideal, the author of this mess understands it, but it is better not to touch something that works.

Most of the data generated by the codes provided in this repository will be saved using the following naming convention.
```
rotate=[rotate]_[chi]_[gilt_eps]_[cg_eps]__[info about particular experiment].[extension]
```
Here, the first part of the name ```rotate=[rotate]_[chi]_[gilt_eps]_[cg_eps]``` characterizes the GiltTNR algorithm uniquely up to the following ambiguity. This convention assumes that no ```bond_repetitions```, ```recursion_depth```, or ```Rmatrices``` were provided (see the list of adjustments in the GiltTNR directory section). Two functions generate entries in the database using this convention: ```trajectory``` and ```plot_the_trajectory``` (in particular their methods with ```relT``` argument). Thus, the user should avoid passing ```bond_repetitions```, ```recursion_depth```, or ```Rmatrices``` into these functions as this will cause ambiguities in the database.    

# Files and directories description

## GiltTNR directory

This directory contains Python codes performing the GiltTNR algorithm (see [this paper](https://journals.aps.org/prb/abstract/10.1103/PhysRevB.97.045111)). It is an assembly of codes from [GiltTNR](https://github.com/GiltTNR/GiltTNR), [tensorRGflow](https://github.com/brucelyu/tensorRGflow), [ncon](https://github.com/mhauru/ncon), [abeliantensors](https://github.com/mhauru/abeliantensors). We applied minor adjustments:

1. We added an option to fix the number of iterations of the Gilt algorithm applied to each bond around a plaquette. It can be fixed by passing a keyword argument ```bond_repetitions```. 
2. We added an option to fix the recursion depth in the optimization procedure that searches for the ```R``` matrix (for the ```R``` matrix definition see [this paper](https://journals.aps.org/prb/abstract/10.1103/PhysRevB.97.045111)). It can be fixed by passing a keyword argument ```recursion_depth``` (together with ```bond_repetitions```) that is a dictionary whose keys belong to ```{"S", "N", "E", "W"}```, and whose values are the recursion depths that should be used at the corresponding leg. Note that at the last Gilt iteration, recursion depth will be automatically set to 1 for all legs as this typically happens when the standard convergence stopping criteria is used.    
3. We added an option to use precomputed ```R``` matrices instead of running the optimization procedure. For this one should pass ```bond_repetitions``` and the keyword argument ```Rmatrices``` which is a dictionary whose keys are the pares ```(bond_key, lap)``` (```lap``` is an integer,```bond_key in {"S", "N", "E", "W"}```) and whose values are the ```R``` matrices which should be applied at the bond ```bond_key``` at ```lap``` iteration of the Gilt.
4. We added an option to choose whether to rotate the tensor after the GiltTNR step. The keyword ```rotate``` controls this.    
5. We modified ```matrix_eig``` and ```matrix_svd``` functions in ```abeliantensor.py``` so that the sign ambiguities in the decomposition are removed.  
6. In "tensor.py" and "abeliantensor.py" we added a global variable '''method''' that controls the method of sign fixing in svd's and eigenvalue decompositions. 

## Lab directory

Contains scripts for computations:

- ```plot_trajectory.jl``` applies the ```GiltTNR``` algorithm ```traj_len``` times to the initial tensor corresponding to 2d nearest neighbors Ising model at the relative temperature ```relT```. It saves the resulting trajectories to the "trajectories" folder in two files: ```*.data``` with tensors, log factors, and errors along the trajectory; ```*.log``` with all the text output of the algorithm. It also saves the plots of the trajectories of the tensor's singular values (obtained by "diagonal" SVD: $A_{ijkl}=U_{ij l} S_l V_{l kl}$).

- ```critical_temperature.jl``` finds the critical temperature using bisection search; saves the result into the "critical_temperatures" directory; plots the corresponding trajectories of the singular values. Saves the plot into the "trajectory_plots" directory. 
 
- ```differentiability_test.jl``` performs differentiability tests of the GiltTNR algorithm. Fixes ```bond_repetitions``` and ```recursion_depth```. Then, chooses a random direction $v$ and computes the numerical derivative $\Delta_n=(GiltTNR(A+s_n v/2)-GiltTNR(A-s_n v/2))/s_n$, where $s_n=10^{-3-0.05n}$. Plots $|\Delta_{n+1}-\Delta_n|/|\Delta_n|$ vs $n$ and saves this plot into the "results" directory. The approximate minimum of this plot should be chosen as the step size in ```newton.jl```. If parameter ```N``` is passed, the script will perform the test for ```N``` random directions. 

- ```eigensystem.jl``` gets the largest eigenvalues and the corresponding eigenvectors of GiltTNR linearised around some initial approximation of the critical tensor (given by ```relT``` and ```number_of_initial_steps```). Saves the resulting tensor and the eigensystem to ```eigensystems```. Note that the script will fix ```bond_repetitions``` and ```recursion_depth```. These parameters will be saved together with the other output.  

- ```newton.jl``` (assumes that ```rotation=true```) repeats the computation from ```eigensystem.jl```. Then, it finds the critical tensor using Newton's method and computes the eigensystem for the linearisation of GiltTNR around this tensor. Saves the resulting tensor and the eigensystem to the "newton" directory. It also saves Newton's method convergence plot to the same directory and the singular values trajectory plot starting from the found tensor. Note that the found critical tensor is the fixed point for gilt with fixed ```bond_repetitions``` and ```recursion_depth```. These parameters will be saved together with the other output.

Note that each script has the corresponding help describing all the command line arguments. To see this help run 
```
julia Lab/script_name.jl --help
```

## Files in the root directory

- ```EchelonForm.jl``` - technical code used in ```GaugeFixing.jl``` for checking ranks of boolean matrices. 
- ```GaugeFixing.jl``` - continuous and discrete gauge fixing routines.
- ```install_packages.jl``` - script that installs all the necessary dependencies and creates the necessary directories.
- ```KrylovTechnical.jl``` - technical code that provides a minimal implementation of Z2 invariant tensors in Julia. This solves the problem of ```KrylovKit``` throwing a segmentation fault while working with PyObjects.
- ```NumDifferentiation.jl``` - provides the function that performs numerical differentiation.
- ```Tools.jl``` - Contains user-dedicated functions. These are listed at the top of the file.     
- ```IsingExactLevels``` and ```IsingEvenExactLevels``` - data about exact 2d Ising spectrum.

# Reproducing all the data from the paper
 
Ensure that your working directory is the root directory of this project. Then, run the ```install_packages.jl``` script to install all the necessary dependencies and create directories for other scripts: 
```
   julia install_packages.jl
```

## Eigenvalues of GiltTNR without rotation at an approximate fixed point

Let us do the computation for $\chi=10$, $gilt eps=1e-4$. To get an approximate fixed point we run the bisection search:
```
nohup julia Lab/critical_temperature.jl --chi 10 --gilt_eps 1e-4 --search_tol 1e-10 &
```

The script will produce the singular values trajectory plot corresponding to the found approximation of the critical temperature. The plot exhibits a plateau corresponding to the part of the trajectory close to the critical tensor. We choose one tensor at this plateau as an approximation of the critical tensor, say the 15th one. Before computing the eigensystem we run the differentiability test and find the optimal differentiation step. Here is the command for this:  

```
nohup julia Lab/differentiability_test.jl --chi 10 --gilt_eps 1e-4 --relT 1.001277863197029 --number_of_initial_steps 15 --N 5 &
```

Note that ```differentiability_test``` will fix the ```bond_repetitions``` and ```recursion_depth```. This should make the resulting RG map differentiable. The script will fix ```bond_repetitions=2```. As for the ```recursion_depth```, it will read off the recursion depths used in GiltTNR before these manipulations and use these values.

Checking the Cauchy test plots in the "diff_tests" directory we see that derivatives converge. The slope of the lines is around $-2$ which is consistent with the numerical differentiation algorithm of order $2$ that is used in the script by default. We also see that stepsize $5e-6$ is an appropriate choice.  

Finally, we may run ```eigensystem.jl``` (no "nohup" this time as it is nice to see the correct eigenvalues printed out in the terminal):
```
julia Lab/eigensystem.jl --chi 10 --gilt_eps 1e-4 --relT 1.001277863197029 --number_of_initial_steps 15 --stp 5e-6 --N 20
```
## Critical fixed point of GiltTNR with rotation

Let us again consider $\chi=10$ and $gilt eps=1e-4$. We need some initial approximation for the critical tensor. Let us run the trajectory at $relT=1$ and check if we see a plateau there.  
```
nohup julia Lab/plot_trajectory.jl --chi 10 --gilt_eps 1e-4 --relT 1.0 --rotate true
``` 

Let us try to use the 5th tensor as the initial approximation:
```
julia Lab/newton.jl --chi 10 --gilt_eps 1e-4 --relT 1.0 --number_of_initial_steps 5 --N 23
```


## Anisotropic intial tensor A

TK (April 5) : This is a temporary stash of info that should eventually be incorporated in Readme.md in a more organized way.

Right now the code that allows anisotropic initial A is in a fork GILT_TNR_R_tk of the original repository GILT_TNR_R.

The initial tensor now depends on two parameters : relT and Jratio. The function initial_tensor() now calls get_initial_tensor_aniso() instead of get_initial_tensor() as before. The function get_initial_tensor_aniso() is defined in GiltTNR2D_Ising_benchmarks.py. It defines a tensor corresponding to the Ising model with Jv/Jh=Jratio and T = relT * T_c. So relT is always the critical case. Note that T_c depends on Jratio. The routine computes T_c. 

relT and Jratio are passed as a dictionary with a name like initialA_pars and entries "relT" and "Jratio". Where ever relT was passed before, it has now been replaced by passing a dictionary (with name that begins with initialA_pars). 

I have tried to make everything backwards compatible with Jratio defaulting to 1. For example, 

```
nohup julia Lab/plot_trajectory.jl --chi 10 --gilt_eps 1e-4 --relT 1.0 --rotate true
``` 
should work as before. Adding Jratio:

```
nohup julia Lab/plot_trajectory.jl --chi 10 --gilt_eps 1e-4 --relT 1.0 --Jratio 0.58 --rotate true
``` 

should generate a trajectory with initial A for the critical model with Jratio=0.58. Of course it is not exactly critical since chi is finite.

database: If Jratio==1, files are named as before. If Jratio is not 1, the file name contains both relT and Jratio.

At the moment you get some compiler warnings from some of my function definitions that need to be cleaned up.

I have checked that plot_trajectory.jl, critical_temperature.jl, plot_trajectory.jl run ok. But I have yet to check all the other programs. 

There are some bash scripts named run... that I use to avoid having to type all the parameters each time I run something. 